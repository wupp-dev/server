import{_ as e,c as a,o,a as s}from"./app.f4fb2ae1.js";var n="/server/assets/fallo-vnc.3eb219aa.png";const y=JSON.parse('{"title":"Gesti\xF3n remota con SSH y VNC","description":"","frontmatter":{"title":"Gesti\xF3n remota con SSH y VNC","lang":"es-ES"},"headers":[{"level":2,"title":"Breve introducci\xF3n","slug":"breve-introduccion"},{"level":2,"title":"Uso habitual","slug":"uso-habitual"},{"level":2,"title":"Reinicios y desencriptaci\xF3n del disco","slug":"reinicios-y-desencriptacion-del-disco"},{"level":2,"title":"Resolviendo problemas","slug":"resolviendo-problemas"},{"level":3,"title":"Reforzando la seguridad","slug":"reforzando-la-seguridad"},{"level":2,"title":"Virtual Network Computing (VNC)","slug":"virtual-network-computing-vnc"}],"relativePath":"equipo/gestion-remota.md","lastUpdated":1659823366000}'),r={name:"equipo/gestion-remota.md"},i=s(`<h1 id="gestion-remota-con-ssh-y-vnc" tabindex="-1">Gesti\xF3n remota con SSH y VNC <a class="header-anchor" href="#gestion-remota-con-ssh-y-vnc" aria-hidden="true">#</a></h1><p>Esta secci\xF3n incluye todas las cosas que hay que hacer en el servidor antes de poder guardarlo, olvidarte de \xE9l y no volver a necesitar enchufarle un monitor y un teclado para gestionarlo.</p><h2 id="breve-introduccion" tabindex="-1">Breve introducci\xF3n <a class="header-anchor" href="#breve-introduccion" aria-hidden="true">#</a></h2><p>Un servidor es un ordenador al que no quieres tenerle conectado ni un monitor ni un teclado <em>(el rat\xF3n no existe)</em> porque no deber\xEDas tener que tocarlo directamente salvo para el mantenimiento f\xEDsico y cambios en la BIOS o en el sistema operativo.</p><p>Pero s\xED que hay que conectarse a \xE9l normalmente para instalar y desinstalar software y para configurarlo. Esto lo haremos desde otro ordenador usando el protocolo <em>Secure Shell (SSH)</em>, que nos permitir\xE1 ejecutar comandos en el servidor, transferir archivos y otras cosas m\xE1s chulas que veremos despu\xE9s. Todo ello con una conexi\xF3n cifrada \u{1F604}</p><p>Es aqu\xED donde se nos plantea un gran problema: Cuando nos podemos conectar al servidor mediante SSH es cuando est\xE1 encendido <em>(y con los discos desencriptados)</em>, pero \xBFy si no estamos en casa y el ordenador se ha tenido que reiniciar o ha habido un apag\xF3n? Entonces el ordenador se quedar\xEDa esperando a que pusi\xE9ramos <em>(\xA1con un teclado!)</em> la contrase\xF1a para desencriptar los discos y as\xED poder seguir encendi\xE9ndose. Esto no mola. Deber\xEDamos de poder desencriptar el ordenador remotamente tambi\xE9n para no tener miedo.</p><p>Este problema lo resolveremos tras preparar el servidor para el uso habitual.</p><h2 id="uso-habitual" tabindex="-1">Uso habitual <a class="header-anchor" href="#uso-habitual" aria-hidden="true">#</a></h2><p>Vamos a empezar dejando lista nuestra v\xEDa para poder gestionar remotamente el servidor cuando est\xE9 encendido.</p><p>Como lo elegimos a la hora de instalar Debian, el servidor ya viene con OpenSSH Server instalado, que por defecto se ejecuta en el puerto <code>22</code>.</p><div class="warning custom-block"><p class="custom-block-title">ADVERTENCIA</p><p>Es recomendable no usar el puerto 22 para SSH, porque, al ser el puerto por defecto, muchos ataques automatizados solo intentan conectarse a ese puerto, as\xED que cambi\xE1ndolo a otro nos ahorraremos posibles problemas. Quien quiera averiguar en qu\xE9 puerto tenemos el SSH podr\xE1 hacerlo con un escaneo de puertos igualmente, pero ya tendr\xE1 que querer atacarte a ti en concreto.</p></div><p>Sin embargo, si intentamos conectarnos desde otro ordenador, no nos dejar\xE1, por dos motivos:</p><ul><li>Tenemos que abrir el puerto en el router.</li><li>Tenemos que permitirlo en el <em>firewall</em> <em>(si tenemos)</em>.</li></ul><p>As\xED que lo que hay que hacer es primero abrir el puerto SSH en el router y, si tenemos un <em>firewall</em>, permitirlo tambi\xE9n. <strong>Si no tenemos un <em>firewall</em>, vamos a instalarlo porque es necesario.</strong> Para ello ejecutamos los siguientes comandos:</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">$ sudo apt install ufw</span></span>
<span class="line"><span style="color:#A6ACCD;">$ sudo ufw allow 22/tcp</span></span>
<span class="line"><span style="color:#A6ACCD;">$ sudo ufw enable</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>Donde <code>22</code> es el puerto de SSH. Con esto ya tenemos el <em>firewall</em> configurado para aceptar conexiones SSH.</p><p>Con esto ya nos podr\xEDamos conectarnos al servidor desde otro ordenador, pero tendr\xEDa que ser con la contrase\xF1a del usuario administrador, cosa que es poco segura, as\xED que vamos a utilizar la autenticaci\xF3n por claves SSH.</p><p>Para configurarla en el ordenador del que nos vayamos a conectar, seguiremos <a href="https://www.digitalocean.com/community/tutorials/how-to-configure-ssh-key-based-authentication-on-a-linux-server" target="_blank" rel="noopener noreferrer">este tutorial</a>. Adem\xE1s, tiene al final una parte de configuraci\xF3n que tambi\xE9n se debe hacer e incluiremos m\xE1s adelante en el tutorial.</p><h2 id="reinicios-y-desencriptacion-del-disco" tabindex="-1">Reinicios y desencriptaci\xF3n del disco <a class="header-anchor" href="#reinicios-y-desencriptacion-del-disco" aria-hidden="true">#</a></h2><p>Por suerte para nosotros, existe un paquete de Debian llamado <code>dropbear-initramfs</code> que nos va a permitir hacer justo lo que queremos. <strong>\xBFQu\xE9 es lo que hace?</strong> Pues para eso hay que entender un poco c\xF3mo se enciende un ordenador con Linux y los discos encriptados.</p><p>El disco duro realmente no est\xE1 encriptado del todo, tiene una partici\xF3n llamada <em>boot</em> que \xFAnicamente contiene la informaci\xF3n necesaria para decirle al ordenador cuando se intenta encender c\xF3mo debe hacerlo. Es decir, le dice al ordenador, entre otras cosas, que los discos est\xE1n encriptados y que hay que introducir una contrase\xF1a para desencriptarlos. A esto se le llama <code>initramfs</code>, que son los archivos b\xE1sicos que se cargan en la RAM cuando el ordenador se enciende y, junto con el kernel de Linux, se ocupan de gestionar el encendido.</p><p>As\xED, <code>dropbear-initramfs</code> es un software que permite que el servidor reciba conexiones SSH en esta fase del encendido, justo a tiempo para poner la contrase\xF1a para desencriptar los discos.</p><p>Y para instalarlo es muy sencillo, solo hay que irse a la terminal del servidor e instalarlo como un paquete normal y corriente escribiendo <code>sudo apt install dropbear-initramfs</code>. <strong>\xBFEso es todo?</strong> Obviamente no, hay que configurarlo.</p><p>Vamos a editar el archivo de configuraci\xF3n, que est\xE1 en <code>/etc/dropbear-initramfs/config</code> y vamos a descomentar y editar la l\xEDnea:</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">DROPBEAR_OPTIONS=&quot;-I 300 -j -k -p 22 -s&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>\xBFQu\xE9 significa esto?</p><ul><li><code>-i 300</code> desconecta a quien se conecte si en 300 segundos no ha realizado ninguna acci\xF3n.</li><li><code>-j</code> deshabilita la redirecci\xF3n de puertos locales.</li><li><code>-k</code> deshabilita la redirecci\xF3n de puertos remotos.</li><li><code>-p 22</code> indica que se ejecute en el puerto 22.</li><li><code>-s</code> Deshabilita la autenticaci\xF3n por contrase\xF1a.</li></ul><p>Como indica el \xFAltimo par\xE1metro, la autenticaci\xF3n por contrase\xF1a est\xE1 deshabilitada, as\xED que utilizaremos tambi\xE9n las claves p\xFAblicas que hayamos autorizado para OpenSSH Server, podemos copiarlas directamente con el comando:</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">$ sudo cp /home/user/.ssh/authorized_keys /etc/dropbear-initramfs/</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>Por \xFAtlimo, para que los cambios tengan efecto, tenemos que escribir <code>sudo update-initramfs -u</code>. Esto guardar\xE1 de nuevo los archivos de <code>initramfs</code> incluyendo los cambios que hemos hecho.</p><h2 id="resolviendo-problemas" tabindex="-1">Resolviendo problemas <a class="header-anchor" href="#resolviendo-problemas" aria-hidden="true">#</a></h2><p>Un problema con el que nos encontramos cuando intentamos conectarnos al servidor por SSH primero para desencriptar los discos y despu\xE9s para el uso normal, es que nos salta este error:</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">$ ssh server@servermamadisimo.xyz</span></span>
<span class="line"><span style="color:#A6ACCD;">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span></span>
<span class="line"><span style="color:#A6ACCD;">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span></span>
<span class="line"><span style="color:#A6ACCD;">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span></span>
<span class="line"><span style="color:#A6ACCD;">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span></span>
<span class="line"><span style="color:#A6ACCD;">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span></span>
<span class="line"><span style="color:#A6ACCD;">It is also possible that a host key has just been changed.</span></span>
<span class="line"><span style="color:#A6ACCD;">The fingerprint for the ED25519 key sent by the remote host is</span></span>
<span class="line"><span style="color:#A6ACCD;">SHA256:I9TWN1skf97h/X9sJgevzZT1kZZQ9hFRQadccKljr7I.</span></span>
<span class="line"><span style="color:#A6ACCD;">Please contact your system administrator.</span></span>
<span class="line"><span style="color:#A6ACCD;">Add correct host key in /home/user/.ssh/known_hosts to get rid of this message.</span></span>
<span class="line"><span style="color:#A6ACCD;">Offending ECDSA key in /home/user/.ssh/known_hosts:2</span></span>
<span class="line"><span style="color:#A6ACCD;">  remove with:</span></span>
<span class="line"><span style="color:#A6ACCD;">  ssh-keygen -f &quot;/home/user/.ssh/known_hosts&quot; -R &quot;servermamadisimo.xyz&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">Host key for servermamadisimo.xyz has changed and you have requested strict checking.</span></span>
<span class="line"><span style="color:#A6ACCD;">Host key verification failed.</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>\xBFQu\xE9 es lo que ocurre? Pues que la IP a la que nos estamos conectando es la misma pero las claves p\xFAblicas del servidor, que son las que se utilizan para verificar su identidad, son distintas. Esto el ordenador lo confunde <em>(por precauci\xF3n)</em> con un intento de suplantar la identidad del servidor, cosa que ser\xEDa muy peligrosa en caso de ser cierta. Por eso no nos deja conectarnos.</p><p>Para que nos deje conectarnos es tan sencillo como eliminar el archivo de <code>known_hosts</code> mencionado en el error, pero entonces cada vez que reinici\xE1semos el servidor tendr\xEDamos que estar eliminando ese archivo para poder conectarnos de nuevo.</p><p>Por suerte, hay un apa\xF1o. Si ponemos Dropbear y OpenSSH Server en puertos distintos en el servidor, podemos utilizar una identidad distinta para cada puerto cuando nos conectemos.</p><div class="danger custom-block"><p class="custom-block-title">PELIGRO</p><p>Una soluci\xF3n que se nos podr\xEDa ocurrir es utilizar la misma clave p\xFAblica y privada para Dropbear y para OpenSSH Server. Esto es una mal\xEDsima idea porque la clave privada de OpenSSH Server es algo que quieres protejer m\xE1s que a tu gato y, por otro lado, la de Dropbear se va a guardar en una parte desencriptada del sistema operativo, porque necesita usarse antes de desencriptar los discos, as\xED que no est\xE1 muy protegida.</p></div><p>Lo primero para esto es utilizar un puerto distinto para OpenSSH Server al que usamos para Dropbear. Para ello, editamos el archivo <code>/etc/ssh/sshd_config</code> y descomentamos la l\xEDnea <code>#Port 22</code> y cambiamos el n\xFAmero, quedando por ejemplo <code>Port 2222</code>.</p><p>Antes de reiniciar el servidor SSH, debemos asegurarnos de que:</p><ul><li>El nuevo puerto est\xE1 abierto en el router.</li><li>El nuevo puerto est\xE1 permitido por el firewall, en el caso de UFW: <code>sudo ufw allow 2222/tcp</code>.</li></ul><p><em>Nuevamente el puerto es de ejemplo y es recomendable cambiarlo a otro.</em></p><p>Por \xFAltimo, reiniciamos el servidor SSH para que los cambios tengan efecto:</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">$ sudo systemctl restart ssh</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">RELATO</p><p>Iv\xE1n mientras escrib\xEDa esto <em>(desde un sitio lejano a la ubicaci\xF3n del servidor)</em> se olvid\xF3 de permitir el nuevo puerto en el firewall y pasaron cosas malas, si quieres leer la historia completa puedes hacerlo <a href="./../relatos/bloqueo-ssh.html">aqu\xED</a>.</p></div><p>Si ahora nos vamos a nuestro ordenador y editamos el archivo <code>/home/user/.ssh/known_hosts</code>...</p><h3 id="reforzando-la-seguridad" tabindex="-1">Reforzando la seguridad <a class="header-anchor" href="#reforzando-la-seguridad" aria-hidden="true">#</a></h3><p>---- POR HACER ----</p><h2 id="virtual-network-computing-vnc" tabindex="-1">Virtual Network Computing (VNC) <a class="header-anchor" href="#virtual-network-computing-vnc" aria-hidden="true">#</a></h2><p>\xBFQu\xE9 mierdas es un VNC? Pues b\xE1sicamente un entorno gr\xE1fico de escritorio remoto. Se utiliza para controlar remotamente otros ordenadores con un escritorio como si fuese realmente tu propio ordenador.</p><p>Hemos seguido <a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-debian-10" target="_blank" rel="noopener noreferrer">este tutorial</a>.</p><p>Como detalles, no hemos establecido una contrase\xF1a para solo vista.</p><p>Aqu\xED da igual cambiar o no el puerto por defecto, ya que no estar\xE1 expuesto directamente a internet.</p><p>En nuestro ordenador podemos instalar <code>xtightvncviewer</code> para conectarnos. Solo tendremos que conectarnos mediante SSH al servidor indicando que queremos redirigir el puerto 5901 de nuestro ordenador al 5901 del del servidor. Esto lo podemos hacer con <code>ssh -L 5901:127.0.0.1:5901 server@servermamadisimo.xyz</code>. Una vez estemos conectados, podemos ejecutar <code>xtightvncviewer</code> desde la terminal, conectarnos a <code>localhost:5901</code> y poner la contrase\xF1a del VNC.</p><p>En nuestro caso, al intentar conectarnos nos encontramos con el siguiente error:</p><p><img src="`+n+`" alt="Fallo VNC"></p><p>Por suerte, se solucion\xF3 instalando un paquete y reiniciando el servidor VNC:</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">$ sudo apt install dbus-x11</span></span>
<span class="line"><span style="color:#A6ACCD;">$ vncserver -kill :1</span></span>
<span class="line"><span style="color:#A6ACCD;">$ vncserver</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Es raro necesitar el servidor VNC, pero justo estoy escribiendo esta parte antes que la de configuraci\xF3n de servidor SSH porque necesito abrir unos puertos en el router y para eso necesito acceder con un navegador desde el servidor. Como era de esperar, Debian no ven\xEDa con navegador instalado, as\xED que para poder usar uno con el VNC instalamos Firefox con <code>sudo apt install firefox-esr</code>.</p></div>`,58),t=[i];function l(c,d,p,u,m,h){return o(),a("div",null,t)}var g=e(r,[["render",l]]);export{y as __pageData,g as default};
