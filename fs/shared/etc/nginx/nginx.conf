user  nginx;

# Nginx crea automáticamente tantos workers como núcleos/hilos útiles vea en la máquina.
worker_processes  auto;

# Subimos el límite de ficheros abiertos por proceso para evitar quedarnos cortos con conexiones y ficheros.
# Ojo: esto tiene que cuadrar con el LimitNOFILE de systemd y con ulimit, si no, no sirve de mucho.
worker_rlimit_nofile  16384;

# Log de errores en modo "normal": suficiente para diagnosticar sin llenar el disco a lo tonto.
error_log  /var/log/nginx/error.log  error;

pid        /run/nginx.pid;

# ---------------------------------------------------------
# EVENTS: concurrencia / aceptación de conexiones
# ---------------------------------------------------------
events {
    # Conexiones simultáneas por worker. Para un servidor con poco tráfico, 1024 suele ir sobrado.
    worker_connections  1024;

    # En Linux, epoll es lo más eficiente para I/O. En muchos casos ya es el valor por defecto,
    # pero dejarlo explícito ayuda a evitar sorpresas.
    use epoll;
}

# ---------------------------------------------------------
# HTTP: configuración global para todos los vhosts
# ---------------------------------------------------------
http {
    # No enviamos la versión de Nginx en las respuestas.
    server_tokens off;

    # Tipos MIME para que Nginx sirva los Content-Type correctamente.
    include       /etc/nginx/mime.types;

    # Si algo no encaja con un MIME conocido, usamos este por defecto.
    default_type  application/octet-stream;

    # -------------------------
    # LOGS
    # -------------------------
    # Access log con timings.
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for" '
                    'rt=$request_time uct=$upstream_connect_time '
                    'uht=$upstream_header_time urt=$upstream_response_time';

    # Buffer en el access log para escribir menos a disco.
    # flush=1m reduce I/O, pero si el servidor cae podríamos perder hasta 1 minuto de logs.
    access_log  /var/log/nginx/access.log  main  buffer=64k  flush=1m;

    # -------------------------
    # RED / I/O
    # -------------------------
    # sendfile acelera el servir archivos estáticos.
    sendfile on;

    # Optimiza el envío de respuestas grandes cuando usamos sendfile.
    tcp_nopush on;

    # Baja latencia en respuestas pequeñas (no espera a juntar paquetes).
    tcp_nodelay on;

    # Keep-alive para no rehacer conexiones todo el rato.
    # 15s es un buen punto medio entre latencia y consumo de recursos.
    keepalive_timeout  15s;
    keepalive_requests 10000;

    # Timeouts defensivos contra clientes lentos o que intentan consumir sockets.
    client_header_timeout  10s;
    client_body_timeout    60s;
    send_timeout           15s;

    # -------------------------
    # LÍMITES / BUFFERS DE REQUEST
    # -------------------------
    # Tamaño máximo de body. Mejor ajustarlo por vhost, pero este valor global es razonable.
    client_max_body_size  5m;

    # Si un cliente se queda colgado y expira, cortamos la conexión de forma más agresiva.
    reset_timedout_connection on;

    # -------------------------
    # CACHE DE METADATOS DE FICHEROS (estáticos)
    # -------------------------
    # Cachea stats/opens para servir estáticos más rápido (sin pasarnos: no esperamos tráfico masivo).
    open_file_cache max=1000 inactive=30s;

    # Revalida cada 30s: suficiente para no servir cosas viejas demasiado tiempo.
    open_file_cache_valid 30s;

    # Solo cachea si se ha pedido al menos 2 veces (evita llenar la cache con peticiones sueltas).
    open_file_cache_min_uses 2;

    # También cachea errores: útil si hay bots pidiendo rutas inexistentes.
    open_file_cache_errors on;

    # -------------------------
    # COMPRESIÓN: gzip
    # -------------------------
    gzip on;

    # Compresión moderada: buen ahorro sin poner en un aprieto a la CPU.
    gzip_comp_level 4;

    # No merece la pena comprimir respuestas demasiado pequeñas.
    gzip_min_length 256;

    # Importante para caches intermedias.
    gzip_vary on;

    # Comprime también respuestas proxied cuando toca.
    gzip_proxied expired no-cache no-store private auth;

    # Tipos típicos para gzip (texto y derivados).
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/javascript
        application/x-javascript
        application/json
        application/xml
        application/xml+rss
        image/svg+xml;

    # -------------------------
    # TLS (base global; ajustar por vhost)
    # -------------------------
    # Certificado
    ssl_certificate     /etc/letsencrypt/live/wupp.dev/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/wupp.dev/privkey.pem;

    # QUIC/HTTP/3 necesita TLS 1.3. Y como no nos preocupa la retrocompatibilidad, no permitimos TLSv1.2.
    ssl_protocols TLSv1.3;

    # Que el cliente elija cipher suite.
    ssl_prefer_server_ciphers off;

    # Desactivamos session tickets: menos superficie de riesgo; a cambio, algo menos de reuso en algunos casos.
    ssl_session_tickets off;

    # 0-RTT desactivado: evita riesgos de replay. Solo activar a conciencia y por vhost.
    ssl_early_data off;

    # Habilitamos HTTP/2 por defecto.
    http2 on;

    # Quitamos cabeceras informativas típicas de apps/frameworks cuando actuamos como proxy/fastcgi.
    proxy_hide_header   X-Powered-By;
    fastcgi_hide_header X-Powered-By;
    fastcgi_hide_header X-Pingback;

    # -------------------------
    # WEBSOCKETS / UPGRADE (útil para varios servicios)
    # -------------------------
    # Esto se usa en los vhosts cuando hacemos proxy y necesitamos soportar Upgrade (WebSockets).
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    # -------------------------
    # RATE LIMITING (aquí solo definimos zonas; se aplica en cada server/location)
    # -------------------------
    # Límite de conexiones simultáneas por IP (zona en memoria).
    limit_conn_zone $binary_remote_addr zone=conn_limit_per_ip:10m;

    # Límite de requests por IP (ajustar por servicio si hace falta).
    limit_req_zone  $binary_remote_addr zone=req_limit_per_ip:10m rate=5r/s;

    # Respuesta estándar cuando limitamos (más claro que un 503).
    limit_conn_status 429;
    limit_req_status  429;

    # Vhosts.
    include /etc/nginx/conf.d/*.conf;
}